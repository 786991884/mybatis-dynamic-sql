<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 1.9.2 from src/site/markdown/docs/conditions.md at 29 September 2020
 | Rendered using Apache Maven Fluido Skin 1.8
-->
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 1.9.2" />
    <title>MyBatis Dynamic SQL &#x2013; Where Conditions</title>
    <link rel="stylesheet" href="../css/apache-maven-fluido-1.8.min.css" />
    <link rel="stylesheet" href="../css/site.css" />
    <link rel="stylesheet" href="../css/print.css" media="print" />
    <script src="../js/apache-maven-fluido-1.8.min.js"></script>
  </head>
  <body class="topBarDisabled">
    <div class="container-fluid">
      <header>
        <div id="banner">
          <div class="pull-left"><a href="../docs/introduction.html" id="bannerLeft"><h2>MyBatis Dynamic SQL</h2>
</a></div>
          <div class="pull-right"><a href="http://www.mybatis.org/" id="bannerRight" title="MyBatis logo"><img src="http://mybatis.github.io/images/mybatis-logo.png"  alt="MyBatis logo"/></a></div>
          <div class="clear"><hr/></div>
        </div>

        <div id="breadcrumbs">
          <ul class="breadcrumb">
        <li id="publishDate">Last Published: 29 September 2020<span class="divider">|</span>
</li>
          <li id="projectVersion">Version: 1.2.1</li>
          </ul>
        </div>
      </header>
      <div class="row-fluid">
        <header id="leftColumn" class="span2">
          <nav class="well sidebar-nav">
  <ul class="nav nav-list">
   <li class="nav-header">User's Guide</li>
    <li><a href="../docs/introduction.html" title="Introduction"><span class="none"></span>Introduction</a></li>
    <li><a href="../docs/CHANGELOG.html" title="Change Log"><span class="none"></span>Change Log</a></li>
    <li><a href="../docs/quickStart.html" title="Quick Start"><span class="none"></span>Quick Start</a></li>
    <li><a href="../docs/databaseObjects.html" title="Modeling Database Objects"><span class="none"></span>Modeling Database Objects</a></li>
    <li><a href="../docs/whereClauses.html" title="WHERE Clause Support"><span class="icon-chevron-down"></span>WHERE Clause Support</a>
     <ul class="nav nav-list">
      <li class="active"><a href="#"><span class="none"></span>WHERE Conditions</a></li>
     </ul></li>
    <li><a href="../docs/select.html" title="SELECT Statements"><span class="icon-chevron-down"></span>SELECT Statements</a>
     <ul class="nav nav-list">
      <li><a href="../docs/complexQueries.html" title="Complex Queries"><span class="none"></span>Complex Queries</a></li>
     </ul></li>
    <li><a href="../docs/delete.html" title="DELETE Statements"><span class="none"></span>DELETE Statements</a></li>
    <li><a href="../docs/insert.html" title="INSERT Statements"><span class="none"></span>INSERT Statements</a></li>
    <li><a href="../docs/update.html" title="UPDATE Statements"><span class="none"></span>UPDATE Statements</a></li>
    <li><a href="../docs/functions.html" title="Database Functions"><span class="none"></span>Database Functions</a></li>
    <li><a href="../docs/mybatis3.html" title="MyBatis3 Support"><span class="none"></span>MyBatis3 Support</a></li>
    <li><a href="../docs/kotlinMyBatis3.html" title="Kotlin Support for MyBatis3"><span class="none"></span>Kotlin Support for MyBatis3</a></li>
    <li><a href="../docs/spring.html" title="Spring Support"><span class="none"></span>Spring Support</a></li>
    <li><a href="../docs/kotlinSpring.html" title="Kotlin Support for Spring"><span class="none"></span>Kotlin Support for Spring</a></li>
    <li><a href="../docs/springBatch.html" title="Spring Batch Support"><span class="none"></span>Spring Batch Support</a></li>
    <li><a href="../docs/howItWorks.html" title="How it Works"><span class="none"></span>How it Works</a></li>
    <li><a href="../docs/extending.html" title="Extending the Library"><span class="none"></span>Extending the Library</a></li>
    <li><a href="../docs/codingStandards.html" title="Coding Standards"><span class="none"></span>Coding Standards</a></li>
    <li><a href="../docs/motivation.html" title="Motivation"><span class="none"></span>Motivation</a></li>
   <li class="nav-header">Project Documentation</li>
    <li><a href="../project-info.html" title="Project Information"><span class="icon-chevron-right"></span>Project Information</a></li>
    <li><a href="../project-reports.html" title="Project Reports"><span class="icon-chevron-right"></span>Project Reports</a></li>
  </ul>
          </nav>
          <div class="well sidebar-nav">
            <hr />
            <div id="poweredBy">
              <div class="clear"></div>
              <div class="clear"></div>
              <div class="clear"></div>
<a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy"><img class="builtBy" alt="Built by Maven" src="../images/logos/maven-feather.png" /></a>
            </div>
          </div>
        </header>
        <main id="bodyColumn"  class="span10" >
<h1>Where Conditions</h1>
<p>MyBatis Dynamic SQL supports a wide variety of where clause conditions. All conditions can be combined with &#x201c;and&#x201d; and &#x201c;or&#x201d; operators to create arbitrarily complex where clauses.</p>
<p>In the following examples:</p>
<ul>

<li>&#x201c;x&#x201d; and &#x201c;y&#x201d; are values that will be rendered as prepared statement parameters. The resulting SQL is rendered in a format that is compatible with the target runtime (either MyBatis or Spring), but we will show standard prepared statement parameter markers for simplicity.</li>
<li>&#x201c;foo&#x201d; and &#x201c;bar&#x201d; are instances of SqlColumn.</li>
</ul><section>
<h2><a name="Simple_Conditions"></a>Simple Conditions</h2>
<p>Simple conditions are the most common - they render the basic SQL operators.</p>
<table border="0" class="table table-striped">
<thead>

<tr class="a">
<th> Condition </th>
<th> Example </th>
<th> Result </th></tr>
</thead><tbody>

<tr class="b">
<td> Between </td>
<td> where(foo, isBetween(x).and(y)) </td>
<td> <code>where foo between ? and ?</code> </td></tr>
<tr class="a">
<td> Equals </td>
<td> where(foo, isEqualTo(x)) </td>
<td> <code>where foo = ?</code> </td></tr>
<tr class="b">
<td> Greater Than </td>
<td> where(foo, isGreaterThan(x)) </td>
<td> <code>where foo &gt; ?</code> </td></tr>
<tr class="a">
<td> Greater Than or Equals </td>
<td> where(foo, isGreaterThanOrEqualTo(x)) </td>
<td> <code>where foo &gt;= ?</code> </td></tr>
<tr class="b">
<td> In </td>
<td> where(foo, isIn(x, y)) </td>
<td> <code>where foo in (?,?)</code> </td></tr>
<tr class="a">
<td> In (case insensitive) </td>
<td> where(foo, isInCaseInsensitive(x, y)) </td>
<td> <code>where upper(foo) in (?,?)</code> (the framework will transform the values for x and y to upper case)</td></tr>
<tr class="b">
<td> Less Than </td>
<td> where(foo, isLessThan(x)) </td>
<td> <code>where foo &lt; ?</code> </td></tr>
<tr class="a">
<td> Less Than or Equals </td>
<td> where(foo, isLessThanOrEqualTo(x)) </td>
<td> <code>where foo &lt;= ?</code> </td></tr>
<tr class="b">
<td> Like </td>
<td> where(foo, isLike(x)) </td>
<td> <code>where foo like ?</code> (the framework DOES NOT add the SQL wild cards to the value - you will need to do that yourself) </td></tr>
<tr class="a">
<td> Like (case insensitive) </td>
<td> where(foo, isLikeCaseInsensitive(x)) </td>
<td> <code>where upper(foo) like ?</code> (the framework DOES NOT add the SQL wild cards to the value - you will need to do that yourself, the framework will transform the value of x to upper case) </td></tr>
<tr class="b">
<td> Not Between </td>
<td> where(foo, isNotBetween(x).and(y)) </td>
<td> <code>where foo not between ? and ?</code> </td></tr>
<tr class="a">
<td> Not Equals </td>
<td> where(foo, isNotEqualTo(x)) </td>
<td> <code>where foo &lt;&gt; ?</code> </td></tr>
<tr class="b">
<td> Not In </td>
<td> where(foo, isNotIn(x, y)) </td>
<td> <code>where foo not in (?,?)</code> </td></tr>
<tr class="a">
<td> Not In (case insensitive) </td>
<td> where(foo, isNotInCaseInsensitive(x, y)) </td>
<td> <code>where upper(foo) not in (?,?)</code> (the framework will transform the values for x and y to upper case)</td></tr>
<tr class="b">
<td> Not Like </td>
<td> where(foo, isLike(x)) </td>
<td> <code>where foo not like ?</code> (the framework DOES NOT add the SQL wild cards to the value - you will need to do that yourself) </td></tr>
<tr class="a">
<td> Not Like (case insensitive) </td>
<td> where(foo, isNotLikeCaseInsensitive(x)) </td>
<td> <code>where upper(foo) not like ?</code> (the framework DOES NOT add the SQL wild cards to the value - you will need to do that yourself, the framework will transform the value of x to upper case) </td></tr>
<tr class="b">
<td> Not Null </td>
<td> where(foo, isNotNull()) </td>
<td> <code>where foo is not null</code> </td></tr>
<tr class="a">
<td> Null </td>
<td> where(foo, isNull()) </td>
<td> <code>where foo is null</code> </td></tr>
</tbody>
</table></section><section>
<h2><a name="Sub-Selects"></a>Sub-Selects</h2>
<p>Many conditions can be rendered with sub selects.</p>
<table border="0" class="table table-striped">
<thead>

<tr class="a">
<th> Condition </th>
<th> Example </th>
<th> Result </th></tr>
</thead><tbody>

<tr class="b">
<td> Equals </td>
<td> where(foo, isEqualTo(select(bar).from(table2).where(bar, isEqualTo(x))) </td>
<td> <code>where foo = (select bar from table2 where bar = ?)</code> </td></tr>
<tr class="a">
<td> Greater Than </td>
<td> where(foo, isGreaterThan(select(bar).from(table2).where(bar, isEqualTo(x))) </td>
<td> <code>where foo &gt; (select bar from table2 where bar = ?)</code> </td></tr>
<tr class="b">
<td> Greater Than  or Equals </td>
<td> where(foo, isGreaterThanOrEqualTo(select(bar).from(table2).where(bar, isEqualTo(x))) </td>
<td> <code>where foo &gt;= (select bar from table2 where bar = ?)</code> </td></tr>
<tr class="a">
<td> In </td>
<td> where(foo, isIn(select(bar).from(table2).where(bar, isLessThan(x))) </td>
<td> <code>where foo in (select bar from table2 where bar &lt; ?)</code> </td></tr>
<tr class="b">
<td> Less Than </td>
<td> where(foo, isLessThan(select(bar).from(table2).where(bar, isEqualTo(x))) </td>
<td> <code>where foo &lt; (select bar from table2 where bar = ?)</code> </td></tr>
<tr class="a">
<td> Less Than  or Equals </td>
<td> where(foo, isLessThanOrEqualTo(select(bar).from(table2).where(bar, isEqualTo(x))) </td>
<td> <code>where foo &lt;= (select bar from table2 where bar = ?)</code> </td></tr>
<tr class="b">
<td> Not Equals </td>
<td> where(foo, isNotEqualTo(select(bar).from(table2).where(bar, isEqualTo(x))) </td>
<td> <code>where foo &lt;&gt; (select bar from table2 where bar = ?)</code> </td></tr>
<tr class="a">
<td> Not In </td>
<td> where(foo, isNotIn(select(bar).from(table2).where(bar, isLessThan(x))) </td>
<td> <code>where foo not in (select bar from table2 where bar &lt; ?)</code> </td></tr>
</tbody>
</table></section><section>
<h2><a name="Column_Comparison_Conditions"></a>Column Comparison Conditions</h2>
<p>Column comparison conditions can be used to write where clauses comparing the values of columns in a table.</p>
<table border="0" class="table table-striped">
<thead>

<tr class="a">
<th> Condition </th>
<th> Example </th>
<th> Result </th></tr>
</thead><tbody>

<tr class="b">
<td> Equals </td>
<td> where(foo, isEqualTo(bar)) </td>
<td> <code>where foo = bar</code> </td></tr>
<tr class="a">
<td> Greater Than </td>
<td> where(foo, isGreaterThan(bar)) </td>
<td> <code>where foo &gt; bar</code> </td></tr>
<tr class="b">
<td> Greater Than or Equals </td>
<td> where(foo, isGreaterThanOrEqualTo(bar)) </td>
<td> <code>where foo &gt;= bar</code> </td></tr>
<tr class="a">
<td> Less Than </td>
<td> where(foo, isLessThan(bar)) </td>
<td> <code>where foo &lt; bar</code> </td></tr>
<tr class="b">
<td> Less Than or Equals </td>
<td> where(foo, isLessThanOrEqualTo(bar)) </td>
<td> <code>where foo &lt;= bar</code> </td></tr>
<tr class="a">
<td> Not Equals </td>
<td> where(foo, isNotEqualTo(bar)) </td>
<td> <code>where foo &lt;&gt; bar</code> </td></tr>
</tbody>
</table></section><section>
<h2><a name="Optional_Conditions"></a>Optional Conditions</h2>
<p>All conditions support optionality - meaning they can be configured to render into the final SQL if a configured test passes.</p>
<p>For example, you could code a search like this:</p>

<div class="source">
<div class="source"><pre class="prettyprint">    public List&lt;AnimalData&gt; searchPeople(String animalName_, Double bodyWeight_, Double brainWeight_) {
        ...
        SelectStatementProvider selectStatement = select(id, animalName, bodyWeight, brainWeight)
                .from(animalData)
                .where(animalName, isEqualTo(animalName_).when(Objects::nonNull))
                .and(bodyWeight, isEqualToWhen(bodyWeight_).when(Objects::nonNull))
                .and(brainWeight, isEqualToWhen(brainWeight_).when(Objects::nonNull))
                .build()
                .render(RenderingStrategies.MYBATIS3);
        ...
    }
</pre></div></div>

<p>In this example, the three conditions will only be rendered if the values passed to them are not null. If all three values are null, then no where clause will be generated.</p>
<p>Each of the conditions accepts a lambda expression that can be used to determine if the condition should render or not. The lambdas will all be of standard JDK types (either <code>java.util.function.BooleanSupplier</code>, <code>java.util.function.Predicate</code>, or <code>java.util.function.BiPredicate</code> depending on the type of condition). The following table lists the optional conditions and shows how to use them:</p>
<table border="0" class="table table-striped">
<thead>

<tr class="a">
<th> Condition </th>
<th> Example </th>
<th> Rendering Rules </th></tr>
</thead><tbody>

<tr class="b">
<td> Between</td>
<td> where(foo, isBetween(x).and(y).when(BiPredicate)) </td>
<td> The library will pass x and y to the BiPredicate&#x2019;s test method. The condition will render if BiPredicate.test(x, y) returns true </td></tr>
<tr class="a">
<td> Equals </td>
<td> where(foo, isEqualTo(x).when(Predicate)) </td>
<td> The library will pass x to the Predicate&#x2019;s test method. The condition will render if Predicate.test(x) returns true </td></tr>
<tr class="b">
<td> Greater Than </td>
<td> where(id, isGreaterThan(x).when(Predicate)) </td>
<td> The library will pass x to the Predicate&#x2019;s test method. The condition will render if Predicate.test(x) returns true </td></tr>
<tr class="a">
<td> Greater Than or Equals </td>
<td> where(id, isGreaterThanOrEqualTo(x).when(Predicate)) </td>
<td> The library will pass x to the Predicate&#x2019;s test method. The condition will render if Predicate.test(x) returns true </td></tr>
<tr class="b">
<td> Less Than </td>
<td> where(id, isLessThan(x).when(Predicate)) </td>
<td> The library will pass x to the Predicate&#x2019;s test method. The condition will render if Predicate.test(x) returns true </td></tr>
<tr class="a">
<td> Less Than or Equals </td>
<td> where(id, isLessThanOrEqualTo(x).when(Predicate)) </td>
<td> The library will pass x to the Predicate&#x2019;s test method. The condition will render if Predicate.test(x) returns true </td></tr>
<tr class="b">
<td> Like </td>
<td> where(id, isLike(x).when(Predicate)) </td>
<td> The library will pass x to the Predicate&#x2019;s test method. The condition will render if Predicate.test(x) returns true </td></tr>
<tr class="a">
<td> Like Case Insensitive </td>
<td> where(id, isLikeCaseInsensitive(x).when(Predicate&lt;String&gt;)) </td>
<td> The library will pass x to the Predicate&#x2019;s test method. The condition will render if Predicate.test(x) returns true </td></tr>
<tr class="b">
<td> Not Between </td>
<td> where(id, isNotBetween(x).and(y).when(BiPredicate)) </td>
<td> The library will pass x and y to the BiPredicate&#x2019;s test method. The condition will render if BiPredicate.test(x, y) returns true </td></tr>
<tr class="a">
<td> Not Equals </td>
<td> where(id, isNotEqualTo(x).when(Predicate)) </td>
<td> The library will pass x to the Predicate&#x2019;s test method. The condition will render if Predicate.test(x) returns true </td></tr>
<tr class="b">
<td> Not Like </td>
<td> where(id, isNotLike(x).when(Predicate)) </td>
<td> The library will pass x to the Predicate&#x2019;s test method. The condition will render if Predicate.test(x) returns true </td></tr>
<tr class="a">
<td> Not Like Case Insensitive </td>
<td> where(id, isNotLikeCaseInsensitive(x).when(Predicate&lt;String&gt;)) </td>
<td> The library will pass x to the Predicate&#x2019;s test method. The condition will render if Predicate.test(x) returns true </td></tr>
<tr class="b">
<td> Not Null </td>
<td> where(id, isNotNull().when(BooleanSupplier) </td>
<td> The condition will render if BooleanSupplier.getAsBoolean() returns true </td></tr>
<tr class="a">
<td> Null </td>
<td> where(id, isNull().when(BooleanSupplier) </td>
<td> The condition will render if BooleanSupplier.getAsBoolean() returns true </td></tr>
</tbody>
</table><section>
<h3><a name="a.E2.80.9CWhen_Present.E2.80.9D_Optional_Conditions"></a>&#x201c;When Present&#x201d; Optional Conditions</h3>
<p>The library supplies several specializations of optional conditions to be used in the common case of checking for null values. The table below lists the rendering rules for each of these &#x201c;when present&#x201d; optional conditions.</p>
<table border="0" class="table table-striped">
<thead>

<tr class="a">
<th> Condition </th>
<th> Example </th>
<th> Rendering Rules </th></tr>
</thead><tbody>

<tr class="b">
<td> Between</td>
<td> where(foo, isBetweenWhenPresent(x).and(y)) </td>
<td> The condition will render if both x and y values are non-null </td></tr>
<tr class="a">
<td> Equals </td>
<td> where(foo, isEqualToWhenPresent(x)) </td>
<td> The condition will render if x is non-null </td></tr>
<tr class="b">
<td> Greater Than </td>
<td> where(id, isGreaterThanWhenPresent(x)) </td>
<td> The condition will render if x is non-null </td></tr>
<tr class="a">
<td> Greater Than or Equals </td>
<td> where(id, isGreaterThanOrEqualToWhenPresent(x)) </td>
<td> The condition will render if x is non-null </td></tr>
<tr class="b">
<td> Less Than </td>
<td> where(id, isLessThanWhenPresent(x)) </td>
<td> The condition will render if x is non-null </td></tr>
<tr class="a">
<td> Less Than orEquals </td>
<td> where(id, isLessThanOrEqualToWhenPresent(x)) </td>
<td> The condition will render if x is non-null </td></tr>
<tr class="b">
<td> Like </td>
<td> where(id, isLikeWhenPresent(x)) </td>
<td> The condition will render if x is non-null </td></tr>
<tr class="a">
<td> Like Case Insensitive </td>
<td> where(id, isLikeCaseInsensitiveWhenPresent(x)) </td>
<td> The condition will render if x is non-null </td></tr>
<tr class="b">
<td> Not Between </td>
<td> where(id, isNotBetweenWhenPresent(x).and(y)) </td>
<td> The condition will render if both x and y values are non-null </td></tr>
<tr class="a">
<td> Not Equals </td>
<td> where(id, isNotEqualToWhenPresent(x)) </td>
<td> The condition will render if x is non-null </td></tr>
<tr class="b">
<td> Not Like </td>
<td> where(id, isNotLikeWhenPresent(x)) </td>
<td> The condition will render if x is non-null </td></tr>
<tr class="a">
<td> Not Like Case Insensitive </td>
<td> where(id, isNotLikeCaseInsensitiveWhenPresent(x)) </td>
<td> The condition will render if x is non-null </td></tr>
</tbody>
</table></section><section>
<h3><a name="Optionality_with_the_.E2.80.9CIn.E2.80.9D_Conditions"></a>Optionality with the &#x201c;In&#x201d; Conditions</h3>
<p>Optionality with the &#x201c;in&#x201d; and &#x201c;not in&#x201d; conditions is a bit more complex than the other types of conditions. The first thing to know is that no &#x201c;in&#x201d; or &#x201c;not in&#x201d; condition will render if the list of values is empty. For example, there will never be rendered SQL like <code>where name in ()</code>. So optionality of the &#x201c;in&#x201d; conditions is more about optionality of the <i>values</i> of the condition. The library comes with functions that will filter out null values, and will upper case String values to enable case insensitive queries. There are extension points to add additional filtering and mapping if you so desire.</p>
<p>We think it is a good thing that the library will not render invalid SQL. An &#x201c;in&#x201d; condition will always be dropped from rendering if the list of values is empty. But there is some danger with this stance. Because the condition could be dropped from the rendered SQL, more rows could be impacted than expected if the list ends up empty for whatever reason. Our recommended solution is to make sure that you validate list values - especially if they are coming from direct user input. Another option is to take some action when the list is empty. This can be especially helpful when you are applying filters to the value list or using one of the built in &#x201c;when present&#x201d; conditions. In that case, it is possible that the list of values could end up empty after a validation check.</p>
<p>The &#x201c;In&#x201d; conditions support a callback that will be invoked when the value list is empty and just before the statement is rendered. You could use the callback to create a condition that will throw an exception when the list is empty. For example:</p>

<div class="source">
<div class="source"><pre class="prettyprint">    private static &lt;T&gt; IsIn&lt;T&gt; isInRequired(Collection&lt;T&gt; values) {
        return IsIn.of(values).withListEmptyCallback(() -&gt; { throw new RuntimeException(&quot;In values cannot be empty&quot;); } );
    }

    // Alternatively, there is a convenience method in the Callback interface
    private static &lt;T&gt; IsIn&lt;T&gt; isInRequired(Collection&lt;T&gt; values) {
        return IsIn.of(values).withListEmptyCallback(Callback.exceptionThrowingCallback(&quot;In values cannot be empty&quot;));
    }
</pre></div></div>

<p>The following table shows the different supplied In conditions and how they will render for different sets of inputs. The table assumes the following types of input:</p>
<ul>

<li>Example 1 assumes an input list of (&#x201c;foo&#x201d;, null, &#x201c;bar&#x201d;) - like <code>where(name, isIn(&quot;foo&quot;, null, &quot;bar&quot;))</code></li>
<li>Example 2 assumes an input list of (null) - like <code>where(name, isIn((String)null))</code></li>
</ul>
<table border="0" class="table table-striped">
<thead>

<tr class="a">
<th> Condition </th>
<th> Nulls Filtered </th>
<th> Strings Mapped to Uppercase </th>
<th> Example 1 Rendering </th>
<th> Example 2 Rendering </th></tr>
</thead><tbody>

<tr class="b">
<td> IsIn</td>
<td> No </td>
<td> No</td>
<td> name in (&#x2018;foo&#x2019;, null, &#x2018;bar&#x2019;) </td>
<td> name in (null) </td></tr>
<tr class="a">
<td> IsInWhenPresent </td>
<td> Yes </td>
<td> No </td>
<td> name in (&#x2018;foo&#x2019;, &#x2018;bar&#x2019;) </td>
<td> No Render </td></tr>
<tr class="b">
<td> IsInCaseInsensitive </td>
<td> No </td>
<td> Yes </td>
<td> upper(name) in (&#x2018;FOO&#x2019;, null, &#x2018;BAR&#x2019;) </td>
<td> upper(name) in (null) </td></tr>
<tr class="a">
<td> IsInCaseInsensitiveWhenPresent </td>
<td> Yes </td>
<td> Yes </td>
<td> upper(name) in (&#x2018;FOO&#x2019;, &#x2018;BAR&#x2019;) </td>
<td> No Render </td></tr>
<tr class="b">
<td> IsNotIn</td>
<td> No </td>
<td> No</td>
<td> name not in (&#x2018;foo&#x2019;, null, &#x2018;bar&#x2019;) </td>
<td> name not in (null) </td></tr>
<tr class="a">
<td> IsNotInWhenPresent </td>
<td> Yes </td>
<td> No </td>
<td> name not in (&#x2018;foo&#x2019;, &#x2018;bar&#x2019;) </td>
<td> No render </td></tr>
<tr class="b">
<td> IsNotInCaseInsensitive </td>
<td> No </td>
<td> Yes </td>
<td> upper(name) not in (&#x2018;FOO&#x2019;, null, &#x2018;BAR&#x2019;) </td>
<td> upper(name) not in (null) </td></tr>
<tr class="a">
<td> IsNotInCaseInsensitiveWhenPresent </td>
<td> Yes </td>
<td> Yes </td>
<td> upper(name) not in (&#x2018;FOO&#x2019;, &#x2018;BAR&#x2019;) </td>
<td> No Render </td></tr>
</tbody>
</table>
<p>If none of these options meet your needs, there is an extension point where you can add your own filter and/or map conditions to the value stream. This gives you great flexibility to alter or filter the value list before the condition is rendered.</p>
<p>The extension point for modifying the value list is the method <code>then(UnaryOperator&lt;Stream&lt;T&gt;&gt;)</code>. This method accepts a <code>UnaryOperator&lt;Stream&lt;T&gt;&gt;</code> in which you can specify map and/or filter operations for the value stream. For example, suppose you wanted to code an &#x201c;in&#x201d; condition that accepted a list of strings, but you want to filter out any null or blank string, and you want to trim all strings. This can be accomplished with code like this:</p>

<div class="source">
<div class="source"><pre class="prettyprint">    SelectStatementProvider selectStatement = select(id, animalName, bodyWeight, brainWeight)
            .from(animalData)
            .where(animalName, isIn(&quot;  Mouse&quot;, &quot;  &quot;, null, &quot;&quot;, &quot;Musk shrew  &quot;)
                    .then(s -&gt; s.filter(Objects::nonNull)
                            .map(String::trim)
                            .filter(st -&gt; !st.isEmpty())))
            .orderBy(id)
            .build()
            .render(RenderingStrategies.MYBATIS3);
</pre></div></div>

<p>This code is a bit cumbersome, so if this is a common use case you could build a specialization of the <code>IsIn</code> condition as follows:</p>

<div class="source">
<div class="source"><pre class="prettyprint">    public class MyInCondition {
        public static IsIn&lt;String&gt; isIn(String...values) {
            return new IsIn.Builder&lt;String&gt;()
                    .withValues(Arrays.asList(values))
                    .withValueStreamTransformer(s -&gt; s.filter(Objects::nonNull)
                            .map(String::trim)
                            .filter(st -&gt; !st.isEmpty()))
                    .build();
        }
    }
</pre></div></div>

<p>Then the condition could be used in a query as follows:</p>

<div class="source">
<div class="source"><pre class="prettyprint">    SelectStatementProvider selectStatement = select(id, animalName, bodyWeight, brainWeight)
            .from(animalData)
            .where(animalName, MyInCondition.isIn(&quot;  Mouse&quot;, &quot;  &quot;, null, &quot;&quot;, &quot;Musk shrew  &quot;))
            .orderBy(id)
            .build()
            .render(RenderingStrategies.MYBATIS3);
</pre></div></div>

<p>You can apply value stream operations to the conditions <code>IsIn</code> and <code>IsNotIn</code>. The built in conditions <code>IsInCaseInsensitive</code>, <code>IsInCaseInsensitiveWhenPresent</code>, <code>IsInWhenPresent</code>, <code>IsNotInCaseInsensitive</code>, <code>IsNotInCaseInsensitiveWhenPresent</code>, and <code>IsNotInWhenPresent</code> do not support additional value stream operations as they already implement a value stream operation as part of the condition.</p></section></section>
        </main>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>Copyright &#169;      2016&#x2013;2020<a href="https://www.mybatis.org/">MyBatis.org</a>.
.</p>
        </div>
      </div>
    </footer>
  </body>
</html>
