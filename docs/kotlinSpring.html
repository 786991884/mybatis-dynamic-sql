<!DOCTYPE html>
<!--
 | Generated by Apache Maven Doxia Site Renderer 1.9.2 from src/site/markdown/docs/kotlinSpring.md at 29 September 2020
 | Rendered using Apache Maven Fluido Skin 1.8
-->
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 1.9.2" />
    <title>MyBatis Dynamic SQL &#x2013; Kotlin Support for Spring</title>
    <link rel="stylesheet" href="../css/apache-maven-fluido-1.8.min.css" />
    <link rel="stylesheet" href="../css/site.css" />
    <link rel="stylesheet" href="../css/print.css" media="print" />
    <script src="../js/apache-maven-fluido-1.8.min.js"></script>
  </head>
  <body class="topBarDisabled">
    <div class="container-fluid">
      <header>
        <div id="banner">
          <div class="pull-left"><a href="../docs/introduction.html" id="bannerLeft"><h2>MyBatis Dynamic SQL</h2>
</a></div>
          <div class="pull-right"><a href="http://www.mybatis.org/" id="bannerRight" title="MyBatis logo"><img src="http://mybatis.github.io/images/mybatis-logo.png"  alt="MyBatis logo"/></a></div>
          <div class="clear"><hr/></div>
        </div>

        <div id="breadcrumbs">
          <ul class="breadcrumb">
        <li id="publishDate">Last Published: 29 September 2020<span class="divider">|</span>
</li>
          <li id="projectVersion">Version: 1.2.1</li>
          </ul>
        </div>
      </header>
      <div class="row-fluid">
        <header id="leftColumn" class="span2">
          <nav class="well sidebar-nav">
  <ul class="nav nav-list">
   <li class="nav-header">User's Guide</li>
    <li><a href="../docs/introduction.html" title="Introduction"><span class="none"></span>Introduction</a></li>
    <li><a href="../docs/CHANGELOG.html" title="Change Log"><span class="none"></span>Change Log</a></li>
    <li><a href="../docs/quickStart.html" title="Quick Start"><span class="none"></span>Quick Start</a></li>
    <li><a href="../docs/databaseObjects.html" title="Modeling Database Objects"><span class="none"></span>Modeling Database Objects</a></li>
    <li><a href="../docs/whereClauses.html" title="WHERE Clause Support"><span class="icon-chevron-down"></span>WHERE Clause Support</a>
     <ul class="nav nav-list">
      <li><a href="../docs/conditions.html" title="WHERE Conditions"><span class="none"></span>WHERE Conditions</a></li>
     </ul></li>
    <li><a href="../docs/select.html" title="SELECT Statements"><span class="icon-chevron-down"></span>SELECT Statements</a>
     <ul class="nav nav-list">
      <li><a href="../docs/complexQueries.html" title="Complex Queries"><span class="none"></span>Complex Queries</a></li>
     </ul></li>
    <li><a href="../docs/delete.html" title="DELETE Statements"><span class="none"></span>DELETE Statements</a></li>
    <li><a href="../docs/insert.html" title="INSERT Statements"><span class="none"></span>INSERT Statements</a></li>
    <li><a href="../docs/update.html" title="UPDATE Statements"><span class="none"></span>UPDATE Statements</a></li>
    <li><a href="../docs/functions.html" title="Database Functions"><span class="none"></span>Database Functions</a></li>
    <li><a href="../docs/mybatis3.html" title="MyBatis3 Support"><span class="none"></span>MyBatis3 Support</a></li>
    <li><a href="../docs/kotlinMyBatis3.html" title="Kotlin Support for MyBatis3"><span class="none"></span>Kotlin Support for MyBatis3</a></li>
    <li><a href="../docs/spring.html" title="Spring Support"><span class="none"></span>Spring Support</a></li>
    <li class="active"><a href="#"><span class="none"></span>Kotlin Support for Spring</a></li>
    <li><a href="../docs/springBatch.html" title="Spring Batch Support"><span class="none"></span>Spring Batch Support</a></li>
    <li><a href="../docs/howItWorks.html" title="How it Works"><span class="none"></span>How it Works</a></li>
    <li><a href="../docs/extending.html" title="Extending the Library"><span class="none"></span>Extending the Library</a></li>
    <li><a href="../docs/codingStandards.html" title="Coding Standards"><span class="none"></span>Coding Standards</a></li>
    <li><a href="../docs/motivation.html" title="Motivation"><span class="none"></span>Motivation</a></li>
   <li class="nav-header">Project Documentation</li>
    <li><a href="../project-info.html" title="Project Information"><span class="icon-chevron-right"></span>Project Information</a></li>
    <li><a href="../project-reports.html" title="Project Reports"><span class="icon-chevron-right"></span>Project Reports</a></li>
  </ul>
          </nav>
          <div class="well sidebar-nav">
            <hr />
            <div id="poweredBy">
              <div class="clear"></div>
              <div class="clear"></div>
              <div class="clear"></div>
<a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy"><img class="builtBy" alt="Built by Maven" src="../images/logos/maven-feather.png" /></a>
            </div>
          </div>
        </header>
        <main id="bodyColumn"  class="span10" >
<h1>Kotlin Support for Spring</h1>
<p>MyBatis Dynamic SQL includes Kotlin extensions that enable an SQL DSL for Kotlin. This is the recommended method of using the library in Kotlin with Spring JDBC template. It is possible to use the Java DSL with Kotlin without modification. The only difficulty with using the Java DSL directly is that the parameters for statements need to be formatted properly for Spring. This may involve the use of a <code>BeanPropertySqlParameterSource</code> or a <code>MapSqlParameterSource</code>. The Kotlin DSL hides all these details.</p>
<p>This page will show our recommended pattern for using the MyBatis Dynamic SQL with Kotlin and Spring JDBC Template. The code shown on this page is from the <code>src/test/kotlin/examples/kotlin/spring/canonical</code> directory in this repository. That directory contains a complete example of using this library with Kotlin and Spring.</p>
<p>All Kotlin support for Spring is available in two packages:</p>
<ul>

<li><code>org.mybatis.dynamic.sql.util.kotlin</code> - contains extension methods and utilities to enable an idiomatic Kotlin DSL for MyBatis Dynamic SQL. These objects can be used for clients using any execution target (i.e. MyBatis3 or Spring JDBC Templates)</li>
<li><code>org.mybatis.dynamic.sql.util.kotlin.spring</code> - contains utilities specifically to simplify integration with Spring JDBC Template</li>
</ul>
<p>The Kotlin support for Spring is implemented as extension methods to <code>NamedParameterJdbcTemplate</code>. There are extension methods to support count, delete, insert, select, and update operations based on SQL generated by this library. For each operation, there are two different methods of executing SQL. With the first method you build the appropriate SQL provider object as a separate step before executing the SQL. The second method combines these two operations into a single step. We will illustrate both approaches below.</p><section>
<h2><a name="General_Note_About_the_Kotlin_DSL"></a>General Note About the Kotlin DSL</h2>
<p>We take the customary approach to DSL building in Kotlin in that we attempt to create a somewhat natural feel for SQL, but not an exact replacement of SQL. The Kotlin DSL relies on the capabilities of the underlying Java DSL and does not replace it. This means that the Kotlin DSL does not add any capabilities that are not already present in the Java DSL. You can continue to use the underlying Java DSL at any time - it functions properly in Kotlin. One of the main features of the Kotlin DSL is that we move away from the method chaining paradigm of the Java DSL and move towards a more idiomatic Kotlin DSL based on lambdas and receiver objects. We think the Kotlin DSL feels more natural - certainly it is a more natural experience for Kotlin.</p>
<p>One consequence of the more natural feel of the Kotlin DSL is that you are free to write unusual looking SQL. For example, you could write a SELECT statement with a WHERE clause after a UNION. Most of the time these unusual usages of the DSL will yield correct results. However, it would be best to use the DSL as shown below to avoid hard to diagnose problems.</p></section><section>
<h2><a name="Kotlin_Dynamic_SQL_Support_Objects"></a>Kotlin Dynamic SQL Support Objects</h2>
<p>Because Kotlin does not support static class members, we recommend a simpler pattern for creating the class containing the support objects. For example:</p>

<div class="source">
<div class="source"><pre class="prettyprint">object PersonDynamicSqlSupport {
    object Person : SqlTable(&quot;Person&quot;) {
        val id = column&lt;Int&gt;(&quot;id&quot;, JDBCType.INTEGER)
        val firstName = column&lt;String&gt;(&quot;first_name&quot;, JDBCType.VARCHAR)
        val lastName = column&lt;String&gt;(&quot;last_name&quot;, JDBCType.VARCHAR)
        val birthDate = column&lt;Date&gt;(&quot;birth_date&quot;, JDBCType.DATE)
        val employed = column&lt;Boolean&gt;(&quot;employed&quot;, JDBCType.VARCHAR).withParameterTypeConverter(booleanToStringConverter)
        val occupation = column&lt;String&gt;(&quot;occupation&quot;, JDBCType.VARCHAR)
        val addressId = column&lt;Int&gt;(&quot;address_id&quot;, JDBCType.INTEGER)
    }
}
</pre></div></div>

<p>This object is a singleton containing the <code>SqlTable</code> and <code>SqlColumn</code> objects that map to the database table.</p>
<p>Note the use of a type converter on the <code>employed</code> column. This allows us to use the column as a Boolean in Kotlin, but store the values &#x201c;Yes&#x201d; or &#x201c;No&#x201d; on the database. The type converter looks like this:</p>

<div class="source">
<div class="source"><pre class="prettyprint">val booleanToStringConverter: (Boolean?) -&gt; String = { it?.let { if (it) &quot;Yes&quot; else &quot;No&quot; } ?: &quot;No&quot; }
</pre></div></div>

<p>The type converter will be used on general insert statements, update statements, and where clauses. It is not used on insert statements that map insert fields to properties in a data class. So you will need to add properties to a data class to use in that case. In the examples below, you will see use of a data class property <code>employedAsString</code>. This can easily be implemented by reusing the converter function as shown below&#x2026;</p>

<div class="source">
<div class="source"><pre class="prettyprint">data class PersonRecord(
    ...
    var employed: Boolean? = null,
    ...
) {
    val employedAsString: String
        get() = booleanToStringConverter(employed)
}
</pre></div></div>
</section><section>
<h2><a name="Count_Method_Support"></a>Count Method Support</h2>
<p>A count query is a specialized select - it returns a single column - typically a long - and supports joins and a where clause.</p>
<p>The library supports three types of count statements:</p>
<ol style="list-style-type: decimal">

<li><code>count(*)</code> - counts the number of rows that match a where clause</li>
<li><code>count(column)</code> - counts the number of non-null column values that match a where clause</li>
<li><code>count(distinct column)</code> - counts the number of unique column values that match a where clause</li>
</ol>
<p>The DSL for count methods looks like this:</p>

<div class="source">
<div class="source"><pre class="prettyprint">    // count(*)
    val countStatement = countFrom(Person) {  // countStatement is a SelectStatementProvider
        where(id, isLessThan(4))
    }

    // count(column)
    val countStatement = countColumn(lastName).from(Person) {  // countStatement is a SelectStatementProvider
        allRows()
    }

    // count(distinct column)
    val countStatement = countDistinctColumn(lastName).from(Person) {  // countStatement is a SelectStatementProvider
        allRows()
    }
</pre></div></div>

<p>Note the somewhat awkward method names <code>countColumn</code>, and <code>countDistinctColumn</code>. The methods are named this way to avoid a name collision with other methods in the <code>SqlBuilder</code>. This awkwardness can be avoided by using the one-step method shown below.</p>
<p>These methods create a <code>SelectStatementProvider</code> that can be executed with an extension method for <code>NamedParameterJdbcTemplate</code> like this:</p>

<div class="source">
<div class="source"><pre class="prettyprint">    val template: NamedParameterJdbcTemplate = getTemplate() // not shown
    val rows = template.count(countStatement) // rows is a Long
</pre></div></div>

<p>This is the two-step execution process. This can be combined into a single step with code like the following:</p>

<div class="source">
<div class="source"><pre class="prettyprint">    val rows = template.countFrom(Person) {
        where(id, isLessThan(4))
    }

    val rows = template.count(lastName).from(Person) {
        where(id, isLessThan(4))
    }

    val rows = template.countDistinct(lastName).from(Person) {
        where(id, isLessThan(4))
    }
</pre></div></div>

<p>There is also an extension method that can be used to count all rows in a table:</p>

<div class="source">
<div class="source"><pre class="prettyprint">    val rows = template.countFrom(Person) {
        allRows()
    }
</pre></div></div>
</section><section>
<h2><a name="Delete_Method_Support"></a>Delete Method Support</h2>
<p>Delete method support enables the creation of methods that execute a delete statement allowing a user to specify a where clause at runtime, but abstracting away all other details.</p>
<p>The DSL for delete methods looks like this:</p>

<div class="source">
<div class="source"><pre class="prettyprint">    val deleteStatement = deleteFrom(Person) {  // deleteStatement is a DeleteStatementProvider
        where(id, isLessThan(4))
    }
</pre></div></div>

<p>This code creates a <code>DeleteStatementProvider</code> that can be executed with an extension method for <code>NamedParameterJdbcTemplate</code> like this:</p>

<div class="source">
<div class="source"><pre class="prettyprint">    val template: NamedParameterJdbcTemplate = getTemplate() // not shown
    val rows = template.delete(deleteStatement)  // rows is an Int
</pre></div></div>

<p>This is the two-step execution process. This can be combined into a single step with code like the following:</p>

<div class="source">
<div class="source"><pre class="prettyprint">    val rows = template.deleteFrom(Person) {
        where(id, isLessThan(4))
    }
</pre></div></div>

<p>There is also an extension method that can be used to count all rows in a table:</p>

<div class="source">
<div class="source"><pre class="prettyprint">    val rows = template.deleteFrom(Person) {
        allRows()
    }
</pre></div></div>
</section><section>
<h2><a name="Insert_Record_Method_Support"></a>Insert Record Method Support</h2>
<p>Insert method support enables the creation of arbitrary insert statements given a class that matches a database row. If you do not with to create such a class, then see the general insert support following this section.</p>
<p>The DSL for insert methods looks like this:</p>

<div class="source">
<div class="source"><pre class="prettyprint">    val record = PersonRecord(100, &quot;Joe&quot;, &quot;Jones&quot;, Date(), true, &quot;Developer&quot;, 1)

    val insertStatement = insert(record).into(Person) {  // insertStatement is an InsertStatementProvider
        map(id).toProperty(&quot;id&quot;)
        map(firstName).toProperty(&quot;firstName&quot;)
        map(lastName).toProperty(&quot;lastName&quot;)
        map(birthDate).toProperty(&quot;birthDate&quot;)
        map(employed).toProperty(&quot;employedAsString&quot;)
        map(occupation).toProperty(&quot;occupation&quot;)
        map(addressId).toProperty(&quot;addressId&quot;)
    }
</pre></div></div>

<p>This code creates an <code>InsertStatementProvider</code> that can be executed with an extension method for <code>NamedParameterJdbcTemplate</code> like this:</p>

<div class="source">
<div class="source"><pre class="prettyprint">    val template: NamedParameterJdbcTemplate = getTemplate() // not shown
    val rows = template.insert(insertStatement)  // rows is an Int
</pre></div></div>

<p>If you want to retrieve generated keys, you can use Spring&#x2019;s KeyHolder as follows:</p>

<div class="source">
<div class="source"><pre class="prettyprint">    val keyHolder = GeneratedKeyHolder()
    val rows = template.insert(insertStatement, keyHolder)  // rows is an Int
</pre></div></div>

<p>This is the two-step execution process. These steps can be combined into a single step with code like the following:</p>

<div class="source">
<div class="source"><pre class="prettyprint">    val record = PersonRecord(100, &quot;Joe&quot;, &quot;Jones&quot;, Date(), true, &quot;Developer&quot;, 1)

    val rows = template.insert(record).into(Person) {
        map(id).toProperty(&quot;id&quot;)
        map(firstName).toProperty(&quot;firstName&quot;)
        map(lastName).toProperty(&quot;lastName&quot;)
        map(birthDate).toProperty(&quot;birthDate&quot;)
        map(employed).toProperty(&quot;employedAsString&quot;)
        map(occupation).toPropertyWhenPresent(&quot;occupation&quot;, record::occupation)
        map(addressId).toProperty(&quot;addressId&quot;)
    }
</pre></div></div>

<p>Note the use of the <code>toPropertyWhenPresent</code> mapping - this will only set the insert value if the value of the property is non null. Also note that you can use the mapping methods to map insert fields to nulls and constants if desired.</p>
<p>Using a KeyHolder with the single step looks like this:</p>

<div class="source">
<div class="source"><pre class="prettyprint">    val keyHolder = GeneratedKeyHolder()
    val record = PersonRecord(100, &quot;Joe&quot;, &quot;Jones&quot;, Date(), true, &quot;Developer&quot;, 1)

    val rows = template.withKeyHolder(keyHolder) {
        insert(record).into(Person) {
            map(id).toProperty(&quot;id&quot;)
            map(firstName).toProperty(&quot;firstName&quot;)
            map(lastName).toProperty(&quot;lastName&quot;)
            map(birthDate).toProperty(&quot;birthDate&quot;)
            map(employed).toProperty(&quot;employedAsString&quot;)
            map(occupation).toPropertyWhenPresent(&quot;occupation&quot;, record::occupation)
            map(addressId).toProperty(&quot;addressId&quot;)
        }
    }
</pre></div></div>
</section><section>
<h2><a name="General_Insert_Method_Support"></a>General Insert Method Support</h2>
<p>General insert method support enables the creation of arbitrary insert statements and does not require the creation of a class matching the database row.</p>
<p>The DSL for general insert methods looks like this:</p>

<div class="source">
<div class="source"><pre class="prettyprint">    val insertStatement = insertInto(Person) {  // insertStatement is a GeneralInsertStatementProvider
        set(id).toValue(100)
        set(firstName).toValue(&quot;Joe&quot;)
        set(lastName).toValue(&quot;Jones&quot;)
        set(birthDate).toValue(Date())
        set(employed).toValue(true)
        set(occupation).toValue(&quot;Developer&quot;)
        set(addressId).toValue(1)
    }
</pre></div></div>

<p>This code creates a <code>GeneralInsertStatementProvider</code> that can be executed with an extension method for <code>NamedParameterJdbcTemplate</code> like this:</p>

<div class="source">
<div class="source"><pre class="prettyprint">    val template: NamedParameterJdbcTemplate = getTemplate() // not shown
    val rows = template.generalInsert(insertStatement)  // rows is an Int
</pre></div></div>

<p>If you want to retrieve generated keys, you can use Spring&#x2019;s KeyHolder as follows:</p>

<div class="source">
<div class="source"><pre class="prettyprint">    val keyHolder = GeneratedKeyHolder()
    val rows = template.generalInsert(insertStatement, keyHolder)  // rows is an Int
</pre></div></div>

<p>This is the two-step execution process. These steps can be combined into a single step with code like the following:</p>

<div class="source">
<div class="source"><pre class="prettyprint">    val myOccupation = &quot;Developer&quot;

    val rows = template.insertInto(Person) {
        set(id).toValue(100)
        set(firstName).toValue(&quot;Joe&quot;)
        set(lastName).toValue(&quot;Jones&quot;)
        set(birthDate).toValue(Date())
        set(employed).toValue(true)
        set(occupation).toValueWhenPresent(myOccupation)
        set(addressId).toValue(1)
    }
</pre></div></div>

<p>Note the use of the <code>toValueWhenPresent</code> mapping - this will only set the insert value if the value of the property is non null. Also note that you can use the mapping methods to map insert fields to nulls and constants if desired.</p>
<p>Using a KeyHolder with the single step looks like this:</p>

<div class="source">
<div class="source"><pre class="prettyprint">    val keyHolder = GeneratedKeyHolder()
    val myOccupation = &quot;Developer&quot;

    val rows = template.withKeyHolder(keyHolder) {
        insertInto(Person) {
            set(id).toValue(100)
            set(firstName).toValue(&quot;Joe&quot;)
            set(lastName).toValue(&quot;Jones&quot;)
            set(birthDate).toValue(Date())
            set(employed).toValue(true)
            set(occupation).toValueWhenPresent(myOccupation)
            set(addressId).toValue(1)
        }
    }
</pre></div></div>
</section><section>
<h2><a name="Multi-Row_Insert_Support"></a>Multi-Row Insert Support</h2>
<p>Multi-row inserts allow you to insert multiple rows into a table with a single insert statement. This is a convenient way to insert multiple rows, but there are some limitations. Multi-row inserts are not intended for large bulk inserts because it is possible to create insert statements that exceed the number of prepared statement parameters allowed in JDBC. For bulk inserts, please consider using a JDBC batch (see below).</p>
<p>The two-step process for multi-row inserts looks like this:</p>

<div class="source">
<div class="source"><pre class="prettyprint">    val record1 = PersonRecord(100, &quot;Joe&quot;, LastName(&quot;Jones&quot;), Date(), true, &quot;Developer&quot;, 1)
    val record2 = PersonRecord(101, &quot;Sarah&quot;, LastName(&quot;Smith&quot;), Date(), true, &quot;Architect&quot;, 2)

    val insertStatement = insertMultiple(record1, record2).into(Person) {// insertStatement is a MultiRowInsertStatementProvider
        map(id).toProperty(&quot;id&quot;)
        map(firstName).toProperty(&quot;firstName&quot;)
        map(lastName).toProperty(&quot;lastNameAsString&quot;)
        map(birthDate).toProperty(&quot;birthDate&quot;)
        map(employed).toProperty(&quot;employedAsString&quot;)
        map(occupation).toProperty(&quot;occupation&quot;)
        map(addressId).toProperty(&quot;addressId&quot;)
    }

    val rows = template.insertMultiple(insertStatement) // rows is an Int
</pre></div></div>

<p>If you want to retrieve generated keys, you can use Spring&#x2019;s KeyHolder as follows:</p>

<div class="source">
<div class="source"><pre class="prettyprint">    val keyHolder = GeneratedKeyHolder()
    val rows = template.insertMultiple(insertStatement, keyHolder)  // rows is an Int
</pre></div></div>

<p>This is the two-step execution process. These steps can be combined into a single step with code like the following:</p>

<div class="source">
<div class="source"><pre class="prettyprint">    val record1 = PersonRecord(100, &quot;Joe&quot;, LastName(&quot;Jones&quot;), Date(), true, &quot;Developer&quot;, 1)
    val record2 = PersonRecord(101, &quot;Sarah&quot;, LastName(&quot;Smith&quot;), Date(), true, &quot;Architect&quot;, 2)

    val rows = template.insertMultiple(record1, record2).into(Person) {
        map(id).toProperty(&quot;id&quot;)
        map(firstName).toProperty(&quot;firstName&quot;)
        map(lastName).toProperty(&quot;lastNameAsString&quot;)
        map(birthDate).toProperty(&quot;birthDate&quot;)
        map(employed).toProperty(&quot;employedAsString&quot;)
        map(occupation).toProperty(&quot;occupation&quot;)
        map(addressId).toProperty(&quot;addressId&quot;)
    }
</pre></div></div>

<p>Using a KeyHolder with the single step looks like this:</p>

<div class="source">
<div class="source"><pre class="prettyprint">    val keyHolder = GeneratedKeyHolder()
    val record1 = PersonRecord(100, &quot;Joe&quot;, LastName(&quot;Jones&quot;), Date(), true, &quot;Developer&quot;, 1)
    val record2 = PersonRecord(101, &quot;Sarah&quot;, LastName(&quot;Smith&quot;), Date(), true, &quot;Architect&quot;, 2)

    val rows = template.withKeyHolder(keyHolder) {
        insertMultiple(record1, record2).into(Person) {
            map(id).toProperty(&quot;id&quot;)
            map(firstName).toProperty(&quot;firstName&quot;)
            map(lastName).toProperty(&quot;lastNameAsString&quot;)
            map(birthDate).toProperty(&quot;birthDate&quot;)
            map(employed).toProperty(&quot;employedAsString&quot;)
            map(occupation).toProperty(&quot;occupation&quot;)
            map(addressId).toProperty(&quot;addressId&quot;)
        }
    }
</pre></div></div>
</section><section>
<h2><a name="Batch_Insert_Support"></a>Batch Insert Support</h2>
<p>Batch inserts use Spring&#x2019;s support for JDBC batches - which is an efficient way for doing bulk inserts that does not have the limitations of multi-row insert. Spring does not support returning generated keys from a JDBC batch, but in all other aspects a JDBC batch will likely perform better for large record sets.</p>
<p>The two-step process for batch inserts looks like this:</p>

<div class="source">
<div class="source"><pre class="prettyprint">    val record1 = PersonRecord(100, &quot;Joe&quot;, LastName(&quot;Jones&quot;), Date(), true, &quot;Developer&quot;, 1)
    val record2 = PersonRecord(101, &quot;Sarah&quot;, LastName(&quot;Smith&quot;), Date(), true, &quot;Architect&quot;, 2)

    val insertStatement = insertBatch(record1, record2).into(Person) {
        map(id).toProperty(&quot;id&quot;)
        map(firstName).toProperty(&quot;firstName&quot;)
        map(lastName).toProperty(&quot;lastNameAsString&quot;)
        map(birthDate).toProperty(&quot;birthDate&quot;)
        map(employed).toProperty(&quot;employedAsString&quot;)
        map(occupation).toProperty(&quot;occupation&quot;)
        map(addressId).toProperty(&quot;addressId&quot;)
    }

    val rows = template.insertBatch(insertStatement) // rows is an IntArray
</pre></div></div>

<p>This is the two-step execution process. These steps can be combined into a single step with code like the following:</p>

<div class="source">
<div class="source"><pre class="prettyprint">    val record1 = PersonRecord(100, &quot;Joe&quot;, LastName(&quot;Jones&quot;), Date(), true, &quot;Developer&quot;, 1)
    val record2 = PersonRecord(101, &quot;Sarah&quot;, LastName(&quot;Smith&quot;), Date(), true, &quot;Architect&quot;, 2)

    val rows = template.insertBatch(record1, record2).into(Person) {
        map(id).toProperty(&quot;id&quot;)
        map(firstName).toProperty(&quot;firstName&quot;)
        map(lastName).toProperty(&quot;lastNameAsString&quot;)
        map(birthDate).toProperty(&quot;birthDate&quot;)
        map(employed).toProperty(&quot;employedAsString&quot;)
        map(occupation).toProperty(&quot;occupation&quot;)
        map(addressId).toProperty(&quot;addressId&quot;)
    }
</pre></div></div>
</section><section>
<h2><a name="Select_Method_Support"></a>Select Method Support</h2>
<p>Select method support enables the creation of methods that execute a query allowing a user to specify a where clause and/or an order by clause and/or pagination clauses at runtime, but abstracting away all other details.</p>
<p>The DSL for select methods looks like this:</p>

<div class="source">
<div class="source"><pre class="prettyprint">    val selectStatement = select(id, firstName, lastName, birthDate, employed, occupation,  // selectStatement is a SelectStatementProvider
        addressId).from(Person) {
        where(id, isLessThan(5))
        and(id, isLessThan(4)) {
            and(id, isLessThan(3)) {
                and(id, isLessThan(2))
            }
        }
        orderBy(id)
        limit(3)
    }
</pre></div></div>

<p>This code creates a <code>SelectStatementProvider</code> that can be executed with an extension method for <code>NamedParameterJdbcTemplate</code> like this:</p>

<div class="source">
<div class="source"><pre class="prettyprint">    val template: NamedParameterJdbcTemplate = getTemplate() // not shown
    val rows = template.selectList(selectStatement) { rs, _ -&gt; // rows is a List of PersonRecord in this case
        PersonRecord().apply {
            id = rs.getInt(1)
            firstName = rs.getString(2)
            lastName = rs.getString(3)
            birthDate = rs.getTimestamp(4)
            employed = &quot;Yes&quot; == rs.getString(5)
            occupation = rs.getString(6)
            addressId = rs.getInt(7)
        }
    }
</pre></div></div>

<p>Note that you must provide a row mapper to tell Spring JDBC how to create result objects.</p>
<p>This is the two-step execution process. This can be combined into a single step with code like the following:</p>

<div class="source">
<div class="source"><pre class="prettyprint">    val rows = template.select(id, firstName, lastName, birthDate, employed, occupation, addressId)
        .from(Person) {
            where(id, isLessThan(4)) {
                and(occupation, isNotNull())
            }
            and(occupation, isNotNull())
            orderBy(id)
            limit(3)
        }.withRowMapper { rs, _ -&gt;
            PersonRecord().apply {
                id = rs.getInt(1)
                firstName = rs.getString(2)
                lastName = rs.getString(3)
                birthDate = rs.getTimestamp(4)
                employed = &quot;Yes&quot; == rs.getString(5)
                occupation = rs.getString(6)
                addressId = rs.getInt(7)
            }
        }
</pre></div></div>

<p>There are similar methods for selecting a single row, or executing a select distinct query. For example, you could implement a &#x201c;select by primary key&#x201d; method using code like this:</p>

<div class="source">
<div class="source"><pre class="prettyprint">    val record = template.selectOne(id, firstName, lastName, birthDate, employed, occupation, addressId)
        .from(Person) {
            where(id, isEqualTo(key))
        }.withRowMapper { rs, _ -&gt;
            PersonRecord().apply {
                id = rs.getInt(1)
                firstName = rs.getString(2)
                lastName = rs.getString(3)
                birthDate = rs.getTimestamp(4)
                employed = &quot;Yes&quot; == rs.getString(5)
                occupation = rs.getString(6)
                addressId = rs.getInt(7)
            }
        }
</pre></div></div>

<p>In this case, the data type for <code>record</code> would be <code>PersonRecord?</code> - a nullable value.</p>
<p>There is also an extension method that can be used to select all rows in a table:</p>

<div class="source">
<div class="source"><pre class="prettyprint">    val rows = template.select(id, firstName, lastName, birthDate, employed, occupation, addressId)
        .from(Person) {
            allRows()
            orderBy(id)
        }.withRowMapper { rs, _ -&gt;
            PersonRecord().apply {
                id = rs.getInt(1)
                firstName = rs.getString(2)
                lastName = rs.getString(3)
                birthDate = rs.getTimestamp(4)
                employed = &quot;Yes&quot; == rs.getString(5)
                occupation = rs.getString(6)
                addressId = rs.getInt(7)
            }
        }
</pre></div></div>

<p>Note that we have supplied an <code>order by</code> clause as well.</p></section><section>
<h2><a name="Update_Method_Support"></a>Update Method Support</h2>
<p>Update method support enables the creation of methods that execute an update allowing a user to specify SET clauses and/or a WHERE clause, but abstracting away all other details.</p>
<p>The DSL for delete methods looks like this:</p>

<div class="source">
<div class="source"><pre class="prettyprint">    val updateStatement = update(Person) {  // updateStatement is an UpdateStatementProvider
        set(firstName).equalTo(&quot;Sam&quot;)
        where(firstName, isEqualTo(&quot;Fred&quot;))
    }
</pre></div></div>

<p>This code creates an <code>UpdateStatementProvider</code> that can be executed with an extension method for <code>NamedParameterJdbcTemplate</code> like this:</p>

<div class="source">
<div class="source"><pre class="prettyprint">    val template: NamedParameterJdbcTemplate = getTemplate() // not shown
    val rows = template.update(updateStatement)  // rows is an Int
</pre></div></div>

<p>This is the two-step execution process. This can be combined into a single step with code like the following:</p>

<div class="source">
<div class="source"><pre class="prettyprint">    val rows = template.update(Person) {
        set(firstName).equalTo(&quot;Sam&quot;)
        where(firstName, isEqualTo(&quot;Fred&quot;))
    }
</pre></div></div>

<p>There a many set mappings that allow setting values to null, constants, etc. There is also a mapping that will only set the column value if the passed value is non null.</p>
<p>If you wish to update all rows in a table, simply omit the where clause:</p>

<div class="source">
<div class="source"><pre class="prettyprint">    val rows = template.update(Person) {
        set(firstName).equalTo(&quot;Sam&quot;)
    }
</pre></div></div></section>
        </main>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>Copyright &#169;      2016&#x2013;2020<a href="https://www.mybatis.org/">MyBatis.org</a>.
.</p>
        </div>
      </div>
    </footer>
  </body>
</html>
