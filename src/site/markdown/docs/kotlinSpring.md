# Kotlin Support for Spring
MyBatis Dynamic SQL includes Kotlin extensions that enable an SQL DSL for Kotlin. This is the recommended method of using the library in Kotlin with Spring JDBC template. It is possible to use the Java DSL with Kotlin without modification. The only difficulty with using the Java DSL directly is that the parameters for statements need to be formatted properly for Spring. This may involve the use of a `BeanPropertySqlParameterSource` or a `MapSqlParameterSource`. The Kotlin DSL hides all these details.

This page will show our recommended pattern for using the MyBatis Dynamic SQL with Kotlin and Spring JDBC Template. The code shown on this page is from the `src/test/kotlin/examples/kotlin/spring/canonical` directory in this repository. That directory contains a complete example of using this library with Kotlin and Spring.

All Kotlin support for Spring is available in two packages:

* `org.mybatis.dynamic.sql.util.kotlin` - contains extension methods and utilities to enable an idiomatic Kotlin DSL for MyBatis Dynamic SQL. These objects can be used for clients using any execution target (i.e. MyBatis3 or Spring JDBC Templates)
* `org.mybatis.dynamic.sql.util.kotlin.spring` - contains utilities specifically to simplify integration with Spring JDBC Template

The Kotlin support for Spring is implemented as extension methods to `NamedParameterJdbcTemplate`. There are extension methods to support count, delete, insert, select, and update operations based on SQL generated by this library. For each operation, there are two different methods of executing SQL. With the first method you build the appropriate SQL provider object as a separate step before executing the SQL. The second method combines these two operations into a single step. We will illustrate both approaches below.

## General Note About the Kotlin DSL

We take the customary approach to DSL building in Kotlin in that we attempt to create a somewhat natural feel for SQL, but not an exact replacement of SQL. The Kotlin DSL relies on the capabilities of the underlying Java DSL and does not replace it. This means that the Kotlin DSL does not add any capabilities that are not already present in the Java DSL. You can continue to use the underlying Java DSL at any time - it functions properly in Kotlin. One of the main features of the Kotlin DSL is that we move away from the method chaining paradigm of the Java DSL and move towards a more idiomatic Kotlin DSL based on lambdas and receiver objects. We think the Kotlin DSL feels more natural - certainly it is a more natural experience for Kotlin.

One consequence of the more natural feel of the Kotlin DSL is that you are free to write unusual looking SQL. For example, you could write a SELECT statement with a WHERE clause after a UNION. Most of the time these unusual usages of the DSL will yield correct results. However, it would be best to use the DSL as shown below to avoid hard to diagnose problems.

## Kotlin Dynamic SQL Support Objects
Because Kotlin does not support static class members, we recommend a simpler pattern for creating the class containing the support objects. For example:

```kotlin
object PersonDynamicSqlSupport {
    object Person : SqlTable("Person") {
        val id = column<Int>("id", JDBCType.INTEGER)
        val firstName = column<String>("first_name", JDBCType.VARCHAR)
        val lastName = column<String>("last_name", JDBCType.VARCHAR)
        val birthDate = column<Date>("birth_date", JDBCType.DATE)
        val employed = column<Boolean>("employed", JDBCType.VARCHAR).withParameterTypeConverter(booleanToStringConverter)
        val occupation = column<String>("occupation", JDBCType.VARCHAR)
        val addressId = column<Int>("address_id", JDBCType.INTEGER)
    }
}
```

This object is a singleton containing the `SqlTable` and `SqlColumn` objects that map to the database table.

Note the use of a type converter on the `employed` column. This allows us to use the column as a Boolean in Kotlin, but store the values "Yes" or "No" on the database. The type converter looks like this:

```kotlin
val booleanToStringConverter: (Boolean?) -> String = { it?.let { if (it) "Yes" else "No" } ?: "No" }
```

The type converter will be used on general insert statements, update statements, and where clauses. It is not used on insert statements that map insert fields to properties in a data class. So you will need to add properties to a data class to use in that case. In the examples below, you will see use of a data class property `employedAsString`. This can easily be implemented by reusing the converter function as shown below...

```kotlin
data class PersonRecord(
    ...
    var employed: Boolean? = null,
    ...
) {
    val employedAsString: String
        get() = booleanToStringConverter(employed)
}
```

## Count Method Support

A count query is a specialized select - it returns a single column - typically a long - and supports joins and a where clause.

The library supports three types of count statements:

1. `count(*)` - counts the number of rows that match a where clause
1. `count(column)` - counts the number of non-null column values that match a where clause
1. `count(distinct column)` - counts the number of unique column values that match a where clause

The DSL for count methods looks like this:

```kotlin
    // count(*)
    val countStatement = countFrom(Person) {  // countStatement is a SelectStatementProvider
        where(id, isLessThan(4))
    }

    // count(column)
    val countStatement = count(lastName) {  // countStatement is a SelectStatementProvider
        from(Person)
    }

    // count(distinct column)
    val countStatement = countDistinct(lastName) {  // countStatement is a SelectStatementProvider
        from(Person)
    }
```

These methods create a `SelectStatementProvider` that can be executed with an extension method for `NamedParameterJdbcTemplate` like this:

```kotlin
    val template: NamedParameterJdbcTemplate = getTemplate() // not shown
    val rows = template.count(countStatement) // rows is a Long
```

This is the two-step execution process. This can be combined into a single step with code like the following:

```kotlin
    val rows = template.countFrom(Person) {
        where(id, isLessThan(4))
    }

    val rows = template.count(lastName) {
        from(Person)
        where(id, isLessThan(4))
    }

    val rows = template.countDistinct(lastName) {
        from(Person)
        where(id, isLessThan(4))
    }
```

There is also a method that can be used to count all rows in a table:

```kotlin
    val rows = template.countFrom(Person) {
        allRows()
    }
```

## Delete Method Support

Delete method support enables the creation of methods that execute a delete statement allowing a user to specify a where clause at runtime, but abstracting away all other details.

The DSL for delete methods looks like this:

```kotlin
    val deleteStatement = deleteFrom(Person) {  // deleteStatement is a DeleteStatementProvider
        where(id, isLessThan(4))
    }
```

This code creates a `DeleteStatementProvider` that can be executed with an extension method for `NamedParameterJdbcTemplate` like this:

```kotlin
    val template: NamedParameterJdbcTemplate = getTemplate() // not shown
    val rows = template.delete(deleteStatement)  // rows is an Int
```

This is the two-step execution process. This can be combined into a single step with code like the following:

```kotlin
    val rows = template.deleteFrom(Person) {
        where(id, isLessThan(4))
    }
```

There is also a method that can be used to count all rows in a table:

```kotlin
    val rows = template.deleteFrom(Person) {
        allRows()
    }
```

## Insert Record Method Support

Insert method support enables the creation of arbitrary insert statements given a class that matches a database row. If you do not with to create such a class, then see the general insert support following this section.

The DSL for insert methods looks like this:

```kotlin
    val record = PersonRecord(100, "Joe", "Jones", Date(), true, "Developer", 1)

    val insertStatement = insert(record).into(Person) {  // insertStatement is an InsertStatementProvider
        map(id).toProperty("id")
        map(firstName).toProperty("firstName")
        map(lastName).toProperty("lastName")
        map(birthDate).toProperty("birthDate")
        map(employed).toProperty("employedAsString")
        map(occupation).toProperty("occupation")
        map(addressId).toProperty("addressId")
    }
```

This code creates an `InsertStatementProvider` that can be executed with an extension method for `NamedParameterJdbcTemplate` like this:

```kotlin
    val template: NamedParameterJdbcTemplate = getTemplate() // not shown
    val rows = template.insert(insertStatement)  // rows is an Int
```

If you want to retrieve generated keys, you can use Spring's KeyHolder as follows:

```kotlin
    val keyHolder = GeneratedKeyHolder()
    val rows = template.insert(insertStatement, keyHolder)  // rows is an Int
```

This is the two-step execution process. These steps can be combined into a single step with code like the following:

```kotlin
    val record = PersonRecord(100, "Joe", "Jones", Date(), true, "Developer", 1)

    val rows = template.insert(record).into(Person) {
        map(id).toProperty("id")
        map(firstName).toProperty("firstName")
        map(lastName).toProperty("lastName")
        map(birthDate).toProperty("birthDate")
        map(employed).toProperty("employedAsString")
        map(occupation).toPropertyWhenPresent("occupation", record::occupation)
        map(addressId).toProperty("addressId")
    }
```

Note the use of the `toPropertyWhenPresent` mapping - this will only set the insert value if the value of the property is non null. Also note that you can use the mapping methods to map insert fields to nulls and constants if desired.

Using a KeyHolder with the single step looks like this:

```kotlin
    val keyHolder = GeneratedKeyHolder()
    val record = PersonRecord(100, "Joe", "Jones", Date(), true, "Developer", 1)

    val rows = template.withKeyHolder(keyHolder) {
        insert(record).into(Person) {
            map(id).toProperty("id")
            map(firstName).toProperty("firstName")
            map(lastName).toProperty("lastName")
            map(birthDate).toProperty("birthDate")
            map(employed).toProperty("employedAsString")
            map(occupation).toPropertyWhenPresent("occupation", record::occupation)
            map(addressId).toProperty("addressId")
        }
    }
```

## General Insert Method Support

General insert method support enables the creation of arbitrary insert statements and does not require the creation of a class matching the database row.

The DSL for general insert methods looks like this:

```kotlin
    val insertStatement = insertInto(Person) {  // insertStatement is a GeneralInsertStatementProvider
        set(id).toValue(100)
        set(firstName).toValue("Joe")
        set(lastName).toValue("Jones")
        set(birthDate).toValue(Date())
        set(employed).toValue(true)
        set(occupation).toValue("Developer")
        set(addressId).toValue(1)
    }
```

This code creates a `GeneralInsertStatementProvider` that can be executed with an extension method for `NamedParameterJdbcTemplate` like this:

```kotlin
    val template: NamedParameterJdbcTemplate = getTemplate() // not shown
    val rows = template.generalInsert(insertStatement)  // rows is an Int
```

If you want to retrieve generated keys, you can use Spring's KeyHolder as follows:

```kotlin
    val keyHolder = GeneratedKeyHolder()
    val rows = template.generalInsert(insertStatement, keyHolder)  // rows is an Int
```

This is the two-step execution process. These steps can be combined into a single step with code like the following:

```kotlin
    val myOccupation = "Developer"

    val rows = template.insertInto(Person) {
        set(id).toValue(100)
        set(firstName).toValue("Joe")
        set(lastName).toValue("Jones")
        set(birthDate).toValue(Date())
        set(employed).toValue(true)
        set(occupation).toValueWhenPresent(myOccupation)
        set(addressId).toValue(1)
    }
```

Note the use of the `toValueWhenPresent` mapping - this will only set the insert value if the value of the property is non null. Also note that you can use the mapping methods to map insert fields to nulls and constants if desired.

Using a KeyHolder with the single step looks like this:

```kotlin
    val keyHolder = GeneratedKeyHolder()
    val myOccupation = "Developer"

    val rows = template.withKeyHolder(keyHolder) {
        insertInto(Person) {
            set(id).toValue(100)
            set(firstName).toValue("Joe")
            set(lastName).toValue("Jones")
            set(birthDate).toValue(Date())
            set(employed).toValue(true)
            set(occupation).toValueWhenPresent(myOccupation)
            set(addressId).toValue(1)
        }
    }
```

## Multi-Row Insert Support
Multi-row inserts allow you to insert multiple rows into a table with a single insert statement. This is a convenient way to insert multiple rows, but there are some limitations. Multi-row inserts are not intended for large bulk inserts because it is possible to create insert statements that exceed the number of prepared statement parameters allowed in JDBC. For bulk inserts, please consider using a JDBC batch (see below).

The two-step process for multi-row inserts looks like this:

```kotlin
    val record1 = PersonRecord(100, "Joe", LastName("Jones"), Date(), true, "Developer", 1)
    val record2 = PersonRecord(101, "Sarah", LastName("Smith"), Date(), true, "Architect", 2)

    val insertStatement = insertMultiple(record1, record2).into(Person) {// insertStatement is a MultiRowInsertStatementProvider
        map(id).toProperty("id")
        map(firstName).toProperty("firstName")
        map(lastName).toProperty("lastNameAsString")
        map(birthDate).toProperty("birthDate")
        map(employed).toProperty("employedAsString")
        map(occupation).toProperty("occupation")
        map(addressId).toProperty("addressId")
    }

    val rows = template.insertMultiple(insertStatement) // rows is an Int
```

If you want to retrieve generated keys, you can use Spring's KeyHolder as follows:

```kotlin
    val keyHolder = GeneratedKeyHolder()
    val rows = template.insertMultiple(insertStatement, keyHolder)  // rows is an Int
```

This is the two-step execution process. These steps can be combined into a single step with code like the following:

```kotlin
    val record1 = PersonRecord(100, "Joe", LastName("Jones"), Date(), true, "Developer", 1)
    val record2 = PersonRecord(101, "Sarah", LastName("Smith"), Date(), true, "Architect", 2)

    val rows = template.insertMultiple(record1, record2).into(Person) {
        map(id).toProperty("id")
        map(firstName).toProperty("firstName")
        map(lastName).toProperty("lastNameAsString")
        map(birthDate).toProperty("birthDate")
        map(employed).toProperty("employedAsString")
        map(occupation).toProperty("occupation")
        map(addressId).toProperty("addressId")
    }
```

Using a KeyHolder with the single step looks like this:

```kotlin
    val keyHolder = GeneratedKeyHolder()
    val record1 = PersonRecord(100, "Joe", LastName("Jones"), Date(), true, "Developer", 1)
    val record2 = PersonRecord(101, "Sarah", LastName("Smith"), Date(), true, "Architect", 2)

    val rows = template.withKeyHolder(keyHolder) {
        insertMultiple(record1, record2).into(Person) {
            map(id).toProperty("id")
            map(firstName).toProperty("firstName")
            map(lastName).toProperty("lastNameAsString")
            map(birthDate).toProperty("birthDate")
            map(employed).toProperty("employedAsString")
            map(occupation).toProperty("occupation")
            map(addressId).toProperty("addressId")
        }
    }
```

## Batch Insert Support
Batch inserts use Spring's support for JDBC batches - which is an efficient way for doing bulk inserts that does not have the limitations of multi-row insert. Spring does not support returning generated keys from a JDBC batch, but in all other aspects a JDBC batch will likely perform better for large record sets.

The two-step process for batch inserts looks like this:

```kotlin
    val record1 = PersonRecord(100, "Joe", LastName("Jones"), Date(), true, "Developer", 1)
    val record2 = PersonRecord(101, "Sarah", LastName("Smith"), Date(), true, "Architect", 2)

    val insertStatement = insertBatch(record1, record2).into(Person) {
        map(id).toProperty("id")
        map(firstName).toProperty("firstName")
        map(lastName).toProperty("lastNameAsString")
        map(birthDate).toProperty("birthDate")
        map(employed).toProperty("employedAsString")
        map(occupation).toProperty("occupation")
        map(addressId).toProperty("addressId")
    }

    val rows = template.insertBatch(insertStatement) // rows is an IntArray
```

This is the two-step execution process. These steps can be combined into a single step with code like the following:

```kotlin
    val record1 = PersonRecord(100, "Joe", LastName("Jones"), Date(), true, "Developer", 1)
    val record2 = PersonRecord(101, "Sarah", LastName("Smith"), Date(), true, "Architect", 2)

    val rows = template.insertBatch(record1, record2).into(Person) {
        map(id).toProperty("id")
        map(firstName).toProperty("firstName")
        map(lastName).toProperty("lastNameAsString")
        map(birthDate).toProperty("birthDate")
        map(employed).toProperty("employedAsString")
        map(occupation).toProperty("occupation")
        map(addressId).toProperty("addressId")
    }
```

## Select Method Support

Select method support enables the creation of methods that execute a query allowing a user to specify a where clause and/or an order by clause and/or pagination clauses at runtime, but abstracting away all other details.

The DSL for select methods looks like this:

```kotlin
    val selectStatement = select(id, firstName, lastName, birthDate, employed, occupation,  // selectStatement is a SelectStatementProvider
        addressId) {
        from(Person)
        where(id, isLessThan(5))
        and(id, isLessThan(4)) {
            and(id, isLessThan(3)) {
                and(id, isLessThan(2))
            }
        }
        orderBy(id)
        limit(3)
    }
```

This code creates a `SelectStatementProvider` that can be executed with an extension method for `NamedParameterJdbcTemplate` like this:

```kotlin
    val template: NamedParameterJdbcTemplate = getTemplate() // not shown
    val rows = template.selectList(selectStatement) { rs, _ -> // rows is a List of PersonRecord in this case
        PersonRecord().apply {
            id = rs.getInt(1)
            firstName = rs.getString(2)
            lastName = rs.getString(3)
            birthDate = rs.getTimestamp(4)
            employed = "Yes" == rs.getString(5)
            occupation = rs.getString(6)
            addressId = rs.getInt(7)
        }
    }
```
Note that you must provide a row mapper to tell Spring JDBC how to create result objects.

This is the two-step execution process. This can be combined into a single step with code like the following:

```kotlin
    val rows = template.select(id, firstName, lastName, birthDate, employed, occupation, addressId) {
            from(Person)
            where(id, isLessThan(4)) {
                and(occupation, isNotNull())
            }
            and(occupation, isNotNull())
            orderBy(id)
            limit(3)
        }.withRowMapper { rs, _ ->
            PersonRecord().apply {
                id = rs.getInt(1)
                firstName = rs.getString(2)
                lastName = rs.getString(3)
                birthDate = rs.getTimestamp(4)
                employed = "Yes" == rs.getString(5)
                occupation = rs.getString(6)
                addressId = rs.getInt(7)
            }
        }
```

There are similar methods for selecting a single row, or executing a select distinct query. For example, you could implement a "select by primary key" method using code like this:

```kotlin
    val record = template.selectOne(id, firstName, lastName, birthDate, employed, occupation, addressId) {
            from(Person)
            where(id, isEqualTo(key))
        }.withRowMapper { rs, _ ->
            PersonRecord().apply {
                id = rs.getInt(1)
                firstName = rs.getString(2)
                lastName = rs.getString(3)
                birthDate = rs.getTimestamp(4)
                employed = "Yes" == rs.getString(5)
                occupation = rs.getString(6)
                addressId = rs.getInt(7)
            }
        }
```

In this case, the data type for `record` would be `PersonRecord?` - a nullable value. 

There is also an optional method that can be used to select all rows in a table:

```kotlin
    val rows = template.select(id, firstName, lastName, birthDate, employed, occupation, addressId) {
            from(Person)
            allRows()  // allRows() is optional - the query works the same with or without it 
            orderBy(id)
        }.withRowMapper { rs, _ ->
            PersonRecord().apply {
                id = rs.getInt(1)
                firstName = rs.getString(2)
                lastName = rs.getString(3)
                birthDate = rs.getTimestamp(4)
                employed = "Yes" == rs.getString(5)
                occupation = rs.getString(6)
                addressId = rs.getInt(7)
            }
        }
```

Note that we have supplied an `order by` clause as well.

## Update Method Support

Update method support enables the creation of methods that execute an update allowing a user to specify SET clauses and/or a WHERE clause, but abstracting away all other details.

The DSL for delete methods looks like this:

```kotlin
    val updateStatement = update(Person) {  // updateStatement is an UpdateStatementProvider
        set(firstName).equalTo("Sam")
        where(firstName, isEqualTo("Fred"))
    }
```

This code creates an `UpdateStatementProvider` that can be executed with an extension method for `NamedParameterJdbcTemplate` like this:

```kotlin
    val template: NamedParameterJdbcTemplate = getTemplate() // not shown
    val rows = template.update(updateStatement)  // rows is an Int
```

This is the two-step execution process. This can be combined into a single step with code like the following:

```kotlin
    val rows = template.update(Person) {
        set(firstName).equalTo("Sam")
        where(firstName, isEqualTo("Fred"))
    }
```

There a many set mappings that allow setting values to null, constants, etc. There is also a mapping that will only set the column value if the passed value is non null.

If you wish to update all rows in a table, simply omit the where clause:

```kotlin
    val rows = template.update(Person) {
        set(firstName).equalTo("Sam")
    }
```
